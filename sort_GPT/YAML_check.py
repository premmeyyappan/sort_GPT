#!/usr/bin/env python3
"""
YAML_check.py

Walk Final_MD and ensure notes without frontmatter get their saved YAML
(pre-generated by YAML_add.py) restored from YAML_content.

Behavior:
- If a Final_MD *.md file already has YAML at the very start, skip it.
- Otherwise, look for the same relative path in YAML_content and, if a valid
  YAML block exists there, prepend it to the Final_MD file.
- If no matching YAML or invalid YAML, skip.

Usage:
  python YAML_check.py --final Final_MD --yaml YAML_content
  python YAML_check.py --final Final_MD --yaml YAML_content --dry-run
"""

import argparse
from pathlib import Path
import re
import sys

YAML_RE = re.compile(r"^---\n[\s\S]*?\n---\n", re.DOTALL)

def has_yaml_frontmatter(text: str) -> bool:
    """True if text starts with a YAML frontmatter block."""
    # Normalize newlines; require YAML at absolute start
    s = text.replace("\r\n", "\n").replace("\r", "\n")
    return bool(YAML_RE.match(s))

def extract_yaml_block(text: str):
    """Return (yaml_block, remainder) if YAML is at the start; else (None, text)."""
    s = text.replace("\r\n", "\n").replace("\r", "\n")
    m = YAML_RE.match(s)
    if not m:
        return None, s
    block = m.group(0)
    if not block.endswith("\n"):
        block += "\n"
    remainder = s[m.end():]
    return block, remainder

def main():
    ap = argparse.ArgumentParser(
        description="Restore YAML frontmatter into Final_MD notes from YAML_content if missing."
    )
    ap.add_argument("--final", required=True, help="Path to Final_MD")
    ap.add_argument("--yaml", required=True, help="Path to YAML_content (from YAML_add.py)")
    ap.add_argument("--dry-run", action="store_true", help="Show actions without writing changes")
    args = ap.parse_args()

    final_dir = Path(args.final).resolve()
    yaml_dir  = Path(args.yaml).resolve()

    if not final_dir.is_dir():
        print(f"ERROR: Final folder not found: {final_dir}")
        sys.exit(1)
    if not yaml_dir.is_dir():
        print(f"YAML_check: No YAML_content folder found at {yaml_dir}, exiting.")
        sys.exit(0)

    already_had_yaml = 0
    restored = 0
    missing_yaml_source = 0
    invalid_yaml_source = 0
    skipped_assets = 0
    errors = 0
    total = 0

    for fpath in final_dir.rglob("*.md"):
        if any(part == "_assets" for part in fpath.parts):
            skipped_assets += 1
            continue

        total += 1
        try:
            text = fpath.read_text(encoding="utf-8", errors="ignore")
        except Exception as e:
            print(f"[WARN] Could not read {fpath}: {e}")
            errors += 1
            continue

        if has_yaml_frontmatter(text):
            already_had_yaml += 1
            continue

        # Find equivalent YAML-only file
        rel = fpath.relative_to(final_dir)
        ypath = yaml_dir / rel

        if not ypath.is_file():
            missing_yaml_source += 1
            continue

        try:
            ytext = ypath.read_text(encoding="utf-8", errors="ignore")
        except Exception as e:
            print(f"[WARN] Could not read YAML source {ypath}: {e}")
            errors += 1
            continue

        yblock, _ = extract_yaml_block(ytext)
        if not yblock:
            # YAML_content should contain only YAML, but be defensive
            invalid_yaml_source += 1
            continue

        new_text = yblock + text.replace("\r\n", "\n").replace("\r", "\n")
        if args.dry_run:
            print(f"[DRY] Would prepend YAML to: {rel}")
        else:
            try:
                fpath.write_text(new_text, encoding="utf-8")
            except Exception as e:
                print(f"[WARN] Could not write {fpath}: {e}")
                errors += 1
                continue

        restored += 1

    print("\nYAML_check complete.")
    print(f"  Notes scanned:            {total}")
    print(f"  Had YAML already:         {already_had_yaml}")
    print(f"  Restored YAML:            {restored}")
    print(f"  Missing YAML source:      {missing_yaml_source}")
    print(f"  Invalid YAML source:      {invalid_yaml_source}")
    if skipped_assets:
        print(f"  Skipped inside _assets/:  {skipped_assets}")
    if errors:
        print(f"  Errors:                   {errors}")

if __name__ == "__main__":
    main()